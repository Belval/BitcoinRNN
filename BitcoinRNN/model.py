import sys
import os
import numpy as np
import tensorflow as tf
import uuid

def import_data(data_path, train_ratio):
    data_labels = np.genfromtxt(data_path, delimiter=',')
    data, labels = data_labels[:, -1:], data_labels[:, -1]
    index_cross_validation = int(np.shape(data)[0] * float(train_ratio))
    index_test = index_cross_validation + int((np.shape(data)[0] - index_cross_validation) / 2)
    train_data, cross_validation_data, test_data = data[0:index_cross_validation, :], data[index_cross_validation:index_test], data 
    train_labels, cross_validation_labels, test_labels = labels[0:index_cross_validation], labels[index_cross_validation:index_test], labels
    return train_data, train_labels, cross_validation_data, cross_validation_labels, test_data, test_labels

def main(args):
    os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'
    training_uuid = str(uuid.uuid4())

    session = tf.Session()
    # Usage : model.py [train_path] [data_path] [train_ratio] [hidden_cell_count] [iteration_count]
    # Parameters:
    #   train_path -> Path where the trained graph and the log should be saved
    #   data_path -> Path to a .csv file generated by the data agregator
    #   train_ratio -> Train/ cross validation + test ratio is the fraction of data used for the training. The remaining % will be divided in two for cross val and test.
    #   hidden_cell_count -> The number of hidden cell in our RNN
    #   iteration_count -> The number of iteration on the training data

    train_data, train_labels, cross_validation_data, cross_validation_labels, test_data, test_labels = import_data(args[2], args[3])
    
    example_count = np.shape(train_data)[0]

    # Now we define our graph
    input_size = np.shape(train_data)[1]
    hidden_cell_count = int(args[4])
    iteration_count = int(args[5])

    input_units = tf.placeholder(tf.float32, (None, None, input_size))
    output_unit = tf.placeholder(tf.float32, (None, None, 1))

    lstm_cell = tf.contrib.rnn.BasicLSTMCell(input_size)

    rnn_outputs, rnn_states = tf.nn.dynamic_rnn(lstm_cell, input_units, dtype=tf.float32)

    final_projection = lambda x: tf.contrib.layers.linear(x, num_outputs=1, activation_fn=None)

    predicted_output = tf.map_fn(final_projection, rnn_outputs)

    loss = tf.reduce_mean(tf.squared_difference(output_unit, predicted_output))

    tf.summary.scalar('loss', loss)

    train = tf.train.AdamOptimizer(learning_rate=3).minimize(loss)

    accuracy = tf.reduce_mean(tf.cast(tf.abs(output_unit - predicted_output), tf.float32))

    tf.summary.scalar('accuracy', accuracy)

    merged = tf.summary.merge_all()

    writer = tf.summary.FileWriter(os.path.join(args[1], training_uuid), graph=session.graph)

    tf.global_variables_initializer().run(session=session)

    # Train / CrossVal / Test code under this comment


    iteration_train_data, iteration_train_labels = np.reshape(train_data, (-1, len(train_data), input_size)), np.reshape(train_labels, (-1, len(train_data), 1))

    reshaped_cross_validation_data, reshaped_cross_validation_labels = np.reshape(cross_validation_data, (-1, len(cross_validation_data), input_size)), np.reshape(cross_validation_labels, (-1, len(cross_validation_data), 1))


    for x in range(iteration_count):
        summary, error, _ = session.run([merged, loss, train], { input_units: iteration_train_data, output_unit: iteration_train_labels })
        writer.add_summary(summary, x)
        print('[{}]Error: {}'.format(x, error))

        if not x % 10:
            error = session.run([loss], { input_units: reshaped_cross_validation_data, output_unit: reshaped_cross_validation_labels })[0]          
            print('Cross validation error: {}'.format(error))

    reshaped_test_data, reshaped_test_labels = np.reshape(test_data, (-1, len(test_data), input_size)), np.reshape(test_labels, (-1, len(test_data), 1))
    error = session.run([loss], { input_units: reshaped_test_data, output_unit: reshaped_test_labels })[0]
    print('Test error: {}'.format(error))

if __name__=='__main__':
    main(sys.argv)
